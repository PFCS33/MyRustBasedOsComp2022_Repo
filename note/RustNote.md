# 1.Rust语言

* 目标：构建高效且可靠的软件
  * performance：没有运行时和垃圾收集器。
    * 代码运行速度快，内存使用效率高。可用来开发对性能要求高的服务
  * reliability：用类型系统和所有权模型，来确保内存安全性和线程安全性
    * 在编译时消除各自潜在的问题
  * productivity:
    * 有丰富的文档、友好的编译器（提供有用的错误信息）和一流的工具集
    * 包括集成的包管理器和构建工具、支持各种编辑器的代码自动补全和类型查看功能、代码 自动格式化工具等

# 2.Cargo

* 是 Rust 的<u>构建系统和包管理器</u>

  * 它可以为你处理很多任务，比如构建代码、下载 dependencies 并编译这些库

* `cargo new project_name`

  * 创建一个cargo管理的项目，结构如下

    ![image-20221103194203182](C:\Users\11731\AppData\Roaming\Typora\typora-user-images\image-20221103194203182.png)

* `cargo build`
  * 在project根目录下调用命令
  * 编译，并在`./target∕debug∕`下生成可执行文件(debug模式)
* `cargo build --release`
  * 在 `debug` 模式下，Rust 编译器不会做任何的优化，只为了尽快的编译完成，让你的开发流程更加顺畅。
  * 添加 `--release` 来编译生成高性能代码
* `cargo run`
  * 在project根目录下调用命令
  * Cargo 若发现文件并没有被改变，就不会重新编译，而是直接运行可执行文件。如果修改了源文件的话，Cargo 会在运行之前重新build项目,在运行可执行文件
* `cargo check`
  * 在project根目录下调用命令
  * 该命令快速检查代码是否可以编译，不产生可执行文件

# 3.基本语法

## 1.关键字

* Rust 语言有一组保留的 关键字（keywords），
* 就像大部分语言一样，它们只能由语言本身使用。你不能使用这些关键字作为变量或函数的名称。大部分关键字有特殊的意义，你将在 Rust 程序中使用它们完成各种任务；
* 一些关键字目前没有相应的功能，是为将来可能添加的功能保留的。可以在附录 A 中找到关键字的列表。

## 2.变量绑定

* 使用 `let` 进行变量绑定 

  * `let x = 17;`

* **隐式类型**绑定: 可以不给出变量类型，由编译器根据上下文推断类型，此处 x 为 i32 类型

  * 编译器不一定总能成功推断类型（或者推断的结果不是用户想要的类型）
  * 此时可以**显式指定类型**：
    * `let x: i16 = 17;`

* **变量可变性**

  * 默认情况下，变量是<u>不可变</u>的

  * 如果要让变量可变，需要使用 `mut` 修饰

    ```rust
    let x = 5;
    x += 1; // error: re-assignment of immutable variable x
    let mut y = 5;
    y += 1; // OK!
    ```

* **变量隐藏** shadowing

  * 可以定义(`let`)一个与之前变量<u>同名的新变量</u>

    * 第二个变量”遮蔽” 第一个变量
      * 此时任何使用该变量名的行为中，都会视为是在使用第二个变量
      * 直到第二个变量自己也被隐藏或第二个变量的作用域结束（可重复使用`let`关键字来多次隐藏）
    * 可以让同一含义<u>不同类型</u>的东西使用<u>同一个变量名</u>

    ```rust
    let x = 17;
    let y = 53;
    // x is not mutable, but we're able to re-bind it
    let x = "Shadowed!";
    ```

    ```rust
    let mut cost = String::new();
    std::io::stdin().read_line(&mut cost).unwrap();
    let cost: f64 = cost.trim().parse().unwrap();
    ```

## 3.常量 constants

* 使用`const` 关键字声明

  * 必须注明值的类型
  * 值不允许改变

  ```rust
  const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
  ```

* 编译时常数，在<u>编译时</u>确定具体值

  * 只能被设置为<u>常量表达式</u>，而不可以是其他任何只能在运行时计算出的值

* 可以在<u>任何作用域</u>中声明，包括<u>全局作用域</u>

* 在声明它的作用域之中，常量在<u>整个程序生命周期</u>中都有效。

## 4.表达式

* 几乎所有东西都是表达式 (expressions)

  * 会返回一个值 (value) 作为结果
  * 例外：变量绑定`let` 语句不是表达式

* 单位元 unit 类型，表示空，写作 `()`

  * 类型 `()` 只有一个可取的值：`()`
  * 可以作为一个值用来占位，但是完全**不占用**任何内存
  * 是<u>默认的返回类型</u>

* 可以在表达式后加分号 `;` 来舍弃它的值，这时它返回 `()`

  * 因此，如果一个函数以分号结尾，它返回 `()`

    ```rust
    fn foo() -> i32 { 5 }	//return 5
    fn bar() -> () { () }	//return ()
    fn baz() -> () { 5; }	//return ()
    fn qux() { 5; }	//default return ()
    ```

* 由于基本上所有东西都是表达式，因此都可以绑定到变量 (作为右值)

  ```rust
  let mut x = -5;
  
  let y = if x > 0 {
  "greater"
  } else {
  "less"
  };
  
  let z = loop {
  x += 10;
  if x > 5 {
  break x;
  }
  };
  ```

## 5.语句

* 对于 Rust 语言而言，这种基于语句（statement）和表达式（expression）的方式是非常重要的，你需要能明确的区分这两个概念
* 语句只是完成了一个具体的操作，但是并没有返回值
  * 必须加 `;` 结尾
  * 不能作为右值

## 6.数据类型

* Rust 是 **静态类型**（statically typed）语言，也就是说在<u>编译时</u>就必须知道所有变量的类型

  * 可以定义变量时不指定类型
    * Rust 编译器很聪明，它可以根据变量的值和上下文中的使用方式来自动推导出变量的类型
  * 当<u>多种类型均有可能</u>时，<u>必须增加类型注解</u>，否则编译不通过

* 在 Rust 中，每一个值都属于某一个数据类型，这告诉 Rust 它被指定为何种数据，以便明确数据处理方式

  * 两类数据类型子集：标量（scalar）和复合（compound）

  * 基本类型：往往是一个最小化原子类型，无法解构为其它类型(一般意义上来说)

    ![image-20221104014723246](C:\Users\11731\AppData\Roaming\Typora\typora-user-images\image-20221104014723246.png)

### 6.1 **标量类型**

* 代表一个单独的值
* 有四种基本的标量类型：<u>整型、浮点型、布尔类型和字符</u>类型

#### 1）整型

* 有不同的大小和符号属性

* `isize` 和 `usize` 类型依赖运行程序的计算机架构：64 位架构上它们是 64 位的， 32 位架构上它们是 32 位的

  ![image-20221104014851956](C:\Users\11731\AppData\Roaming\Typora\typora-user-images\image-20221104014851956.png)

* 字面值 (literals) 

  * 可在末尾后缀类型名
    *  写为 `10i8`、`10u16`、`10.0f32`、`10usize` 等
  * 如果不指定类型，则默认整数为 `i32`，浮点数为 `f64`
  * 允许使用 _ 做为分隔符以方便读数`98_222`

#### 2）浮点型

* Rust 的浮点数类型是 `f32` 和 `f64` 。默认类型是 `f64`

* 浮点数采用 IEEE-754 标准表示

* 综合举例

  ```rust
  fn main() {
    // 编译器会进行自动推导，给予twenty i32的类型
    let twenty = 20;
    // 类型标注
    let twenty_one: i32 = 21;
    // 通过类型后缀的方式进行类型标注：22是i32类型
    let twenty_two = 22i32;
  
    // 只有同样类型，才能运算
    let addition = twenty + twenty_one + twenty_two;
    println!("{} + {} + {} = {}", twenty, twenty_one, twenty_two, addition);
  
    // 对于较长的数字，可以用_进行分割，提升可读性
    let one_million: i64 = 1_000_000;
    println!("{}", one_million.pow(2));
  
    // 定义一个f32数组，其中42.0会自动被推导为f32类型
    let forty_twos = [
      42.0,
      42f32,
      42.0_f32,
    ];
  
    // 打印数组中第一个值，并控制小数位为2位
    println!("{:.2}", forty_twos[0]);
  }
  ```

#### 3）拓展

* **类型转换必须是显式的**. Rust 永远也不会偷偷把你的 16bit 整数转换成 32bit 整数

* **Rust 的数值上可以使用方法**. 例如你可以用以下方法来将 `13.14` 取整：`13.14_f32.round()`，在这里我们使用了类型后缀，因为编译器需要知道 `13.14` 的具体类型

* 数字运算

  * Rust 中的所有数字类型，都支持基本数学运算：加法、减法、乘法、除法和取余

    ```rust
    fn main() {
        // 加法
        let sum = 5 + 10;
    
        // 减法
        let difference = 95.5 - 4.3;
    
        // 乘法
        let product = 4 * 30;
    
        // 除法
        let quotient = 56.7 / 32.2;
    
        // 求余
        let remainder = 43 % 5;
    }	//这些语句中的每个表达式都使用了数学运算符，并且计算结果为一个值，然后绑定到一个变量上
    ```

* 位运算：基本上和其他语言一样

* 有理数和复数：未包含在标准库中

  * 好在社区已经开发出高质量的 Rust 数值库：[num](https://crates.io/crates/num)

#### 4）布尔型

* 使用 `bool` 声明
* 有两个可能的值：`true` 和 `false`

#### 5）字符类型

* 使用 `char` 声明

* 用单引号`''`声明 `char` 字面量

* Unicode 类型, 长度为4字节

  * 所以人直觉上的 “字符” 可能与 Rust 中的 `char` 并不符合

  ```rust
  fn main() {
      let c = 'z';
      let z: char = 'ℤ'; // with explicit type annotation
      let heart_eyed_cat = '😻';
  }
  ```

### 6.2 复合类型

* Rust 有两个原生的复合类型：元组（tuple）和数组（array）

#### 1）元组类型

* <u>固定长度的、有序的、异构</u>的列表类型

  * 长度固定：一旦声明，其长度不会增大或缩小
  * 异构：将多个不同类型的值，组合进一个复合类型的主要方式

* 使用包含在圆括号`()`中的逗号`,`分隔的值列表, 来创建一个元组

  ```rust
  fn main() {
      let tup: (i32, f64, u8) = (500, 6.4, 1);
  }	//可以不声明tup类型，让编译器猜
  ```

* 可以使用点号 `.`后跟值的索引（下标）来直接访问元组分量，例如 `tup.0`

* 解构

  * 因为元组是一个单独的复合元素。为了从元组中获取单个值，可以使用 `let` , 模式匹配（pattern matching）来解构（destructure）元组值

    ```rust
    fn main() {
        let tup = (500, 6.4, 1);
    	let (a, b, c) = (72, 'H', 5.1);
        let (x, y, z) = tup;
        println!("The value of y is: {y}");
    }
    ```

* 不带任何值的元组有个特殊的名称，叫做 **单元（unit）** 元组。这种值以及对应的类型都写作 `()`，表示空值或空的返回类型。

#### 2) 数组类型

* <u>固定长度的，有序的，同类的</u>列表类型

  * 数组中的每个元素的类型必须相同
  * 数组长度是固定的

* 将数组的值写成在方括号 `[]` 内，用逗号 `,` 分隔, 创建一个数组

  * 数组的类型声明： `[T; N]` , T 为元素类型，N 为元素数量

    ```rust
    let a: [i32; 5] = [1, 2, 3, 4, 5];
    ```

  * 还可以通过在 `[]` 中指定初始值, 加`;`, 再加元素个数的方式, 来创建一个每个元素都为相同值的数组

    ```rust
    let a = [3; 5];
    ```

* 用 `[]` 来访问数组元素，数组下标从 0 开始

* 无效的数组元素访问处理

  * 运行时 (runtime) 访问数组元素，会检查是否越界。
  * 如果越界，导致 **运行时** 错误，会程序带着错误信息退出，并且没有执行最后的 `println!` 语句
    * 通过立即退出而不是允许内存访问并继续执行，Rust 让你避开此类错误。

* 切片：

  * 类型的形式为 &[T] ，T为数据类型
  * 表示引用数组中的一部分所形成的视图，不能直接创建，需要从别的变量借用 (borrow)

#### 3）字符串

* Rust 有两种字符串：String 和 &str

* String 是在堆上分配空间、可以增长的字符序列

* &str 是 String 的切片类型

  * 形如 "foo" 的字符串字面值都是 &str 类型的

  ```rust
  let s: &str = "galaxy";
  let s2: String = "galaxy".to_string(); 	//显示类型转换
  let s3: String = String::from("galaxy");
  let s4: &str = &s3;
  ```

#### 4）向量 Vec < T >

* 标准库提供的类型，可直接使用。

  * Vec 是分配在堆上的、可增长的数组

* 表示泛型，使用时代入实际的类型

* 使用 Vec::new() 或 vec! 宏来创建 Vec

  ```rust
  // Explicit typing
  let v0: Vec<i32> = Vec::new();
  // v1 and v2 are equal
  let mut v1 = Vec::new();
  v1.push(1);
  v1.push(2);
  v1.push(3);
  let v2 = vec![1, 2, 3];
  // v3 and v4 are equal
  let v3 = vec![0; 4];
  let v4 = vec![0, 0, 0, 0];
  let v2 = vec![1, 2, 3];
  let x = v2[2]; // 3
  ```

  * 向量可以像数组一样使用 [] 来访问元素
    * 若用变量作为下标，必须使用 usize 类型的值，因为 usize 保证和指针是一样长度的
    * 其他类型要显式转换成 usize

## 7.函数

* 函数名和变量名使用 蛇形命名法 (snake case)

* 函数的位置可以随便放，Rust 不关心我们在哪里定义了函数，只要有定义即可

* 函数定义：

  ```rust
  fn foo(x: T, y: U, z: V) -> T {
  // ...
  }
  ```

  * Rust 是强类型语言，必须显式定义函数的<u>参数和返回值的类型</u>
    * 实际上编译器是可以推断函数的参数和返回值的类型的，但是 Rust 的设计者认为显式指定是 一种更好的实践。
    * 而且，在知道函数需要什么类型后，编译器就能够给出更有用的错误消息。

* 函数返回

  * 在 Rust 中，函数的返回值，等同于函数体<u>最后一个表达式的值</u>

  * 使用 `return` 关键字和指定值，可从函数中提前返回；

    * 但大部分函数隐式的返回最后的表达式

  * 若没有显示定义返回值类型，则默认为`()`

    ```rust
    fn main() {
        let x = plus_or_minus(5);
    
        println!("The value of x is: {}", x);
    }
    ```

## 8. 控制流

* if

  * 格式

    * 与 C++ 不同，条件部分不需要用小括号括起来
    * 整个条件语句是当做一个表达式来求值的，因此<u>每个分支都</u>必须是<u>相同类型的表达式</u>
      * 代码块的值是其最后一个表达式的值
      * 当然，如果作为普通的条件语句来使用的话，可以令类型是 ()

    ```rust
    if x > 0 {
    10
    } else if x == 0 {
    0
    } else {
    println!("Not greater than zero!");
    -10
    }
    ```

  * 条件 **必须** 是 `bool` 值

    * Rust 并不会尝试自动地将非布尔值转换为布尔值

  * 由于 `if` 是一个表达式，我们可以在 `let` 语句的右侧使用它

    ```rust
    fn main() {
        let condition = true;
        let number = if condition { 5 } else { 6 };
    
        println!("The value of number is: {number}");
    }
    ```

* 循环

  * while

    * while 的用法与 C++ 相同，只是条件部分不需要用小括号括起来

      ```rust
      let mut x = 0;
      while x < 100 {
      x += 1;
      println!("x: {}", x);
      }
      ```

  * loop

    * `loop` 关键字. 告诉 Rust 一遍又一遍地执行一段代码直到你明确要求停止 `break` 

      * 相当于 while true

    * `break` 语句可以返回一个值，作为整个循环的求值结果

      * 另外两种循环没 有这个功能

      ```rust
      let mut x = 0;
      let y = loop {
      x += 1;
      if x * x >= 100 {
      break x;
      }
      };
      ```

    * 循环标签：在多个循环之间消除歧义

      * 你可以选择在一个循环上指定一个 **循环标签**（*loop label*），然后将标签与 `break` 或 `continue` 一起使用

  * for：

    * 使用迭代器 (iterators) 表达式，遍历集合中的元素

      * `n..m` 创建一个从 n 到 m 半闭半开区间的迭代器。
      * `n..=m` 创建一个从 n 到 m 闭区间的迭代器。
      * 很多数据结构可以当做迭代器来使用，比如数组、切片，Vec 等等

      ```rust
      // Loops from 0 to 9.
      for x in 0..10 {
      println!("{}", x);
      }
      let xs = [0, 1, 2, 3, 4];
      // Loop through elements in a slice of `xs`.
      for x in &xs {
      println!("{}", x);
      }
      ```

  * 匹配语句

    * 由一个表达式 (x) 和一组 value => expression 的分支语句组成
    * 整个匹配语句被视为一个表达式来求值
      * 与 if 类似，所有分支都必须是同样类型的值
    * 下划线 (_) 用于捕捉所有情况
    * 高级
      * 匹配的表达式可以是任意表达式，包括元组和函数调用。 
        * 构成模式 (patterns)。 
        * 匹配可以绑定变量，_ 用来忽略不需要的部分
      * 为了通过编译，必须写穷尽的匹配模式。 
      * 可以用 if 来限制匹配的条件

    ```rust
    let x = 3;
    match x {
    1 => println!("one fish"), // <- comma required
    2 => {
    println!("two fish");
    println!("two fish");
    }, // <- comma optional when using braces
    _ => println!("no fish for you"), // "otherwise" case
    }
    ```

## 9.代码风格

* 名字 

  * 骆驼形式（CamelCase）：类型名 
  * 蛇形形式（snake_case）：变量名、函数名 

* 缩进与空白 

  * Rust 的缩进用 4 个空格字符。 
  * 符号前后的空格操作符
    * 前后各有一个空格，例如 x + 1。 
    * 分隔符后面有一个空格，例如 f(x, 1)。 

* 注释之道 

  * 写注释 
  * 写有意义的注释 
  * 尽量用英文写注释


# 4.所有权

## 1.什么是所有权

### 1.1 前言

* Rust 之所以能成为万众瞩目的语言，就是因为其<u>内存安全性</u>
  * 在计算机语言不断演变过程中，出现了三种流派来管理内存
    * **垃圾回收机制(GC)**，在程序运行时不断寻找不再使用的内存
      * 典型代表：Java、Go
    * **手动管理内存的分配和释放**, 在程序中，通过函数调用的方式来申请和释放内存
      * 典型代表：C++
    * **通过所有权来管理内存**，编译器在编译时会根据一系列规则进行检查
      * 这种检查<u>只发生在编译期</u>，因此对于程序运行期，<u>不会有任何性能上的损失</u>
* Stack & Heap
  * 栈和堆的核心目标, 就是为程序在<u>运行时提供可供使用的内存空间</u>。

    * 但对于 Rust 这样的系统编程语言，值是位于栈上还是堆上非常重要, 因为这会影响程序的行为和性能
  * 栈：栈中的所有数据，都必须占用<u>已知且固定大小</u>的内存空间
  * 堆：对于大小未知或者可能变化的数据，我们需要将它存储在堆上。是一种缺乏组织的数据结构
    * 分配：
      * 当向堆上放入数据时，需要请求一定大小的内存空间。操作系统在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的**指针**, 该过程被称为**在堆上分配内存**
      * 接着，该指针会被推入**栈**中（指针的大小是已知且固定的）。在后续使用过程中，你将通过栈中的**指针**，访问堆的数据
  * 性能区别：
    * 写入方面：入栈比在堆上分配内存要快
    * 读取方面：访问堆上的数据比访问栈上的数据慢
      * 得益于 CPU 高速缓存，栈数据往往可以直接存储在 CPU 高速缓存中，而堆数据只能存储在内存中
    * 因此，处理器处理和分配在<u>栈上数据</u>会比在堆上的数据<u>更加高效</u>
  * 堆栈与内存管理
    * 栈：当你的代码调用一个函数时，传递给函数的<u>参数</u>（包括可能指向<u>堆上数据的指</u>针和函数的<u>局部变量</u>）依次被压入栈中，当函数调用结束时，这些值将被从栈中按照相反的顺序<u>依次移除</u>
    * 堆：因为堆上的数据缺乏组织，因此跟踪这些数据何时分配和释放是非常重要的，否则堆上的数据将产生内存泄漏 —— 这些数据将永远无法被回收
      * Rust 所有权系统能为堆数据管理，提供强大保障

### 1.2 所有权原则

* 三大规则

  * Rust 中每一个值都<u>被一个变量所拥有</u>，该变量被称为值的 **Owner**
  * 一个值同时<u>只能被一个变量</u>所拥有，或者说一个值只能拥有一个 Owner
  * 当 Owner (变量) 离开<u>作用域</u>范围时，这个值将被丢弃(drop)
    * 对于在堆上分配的数据，这意味着在拥有它的变量离开作用域后，就被自动释放
      * Rust 会自动为我们调用一个特殊的函数 drop

* 变量作用域

  * 一个变量在程序中有效的范围
  * 一个变量，从创建到作用域结束这段区间，是有效的
    * 就作用域来说，Rust 语言跟其他编程语言没有区别

  ```rust
  fn main() {
  {                      // s 在这里无效，它尚未声明
      let s = "hello";   // 从此处起，s 是有效的
      // 使用 s
  }                      // 此作用域已结束，s不再有效
  }
  ```

### 1.3 变量绑定

* 所有权绑定

  * 通过变量绑定语句 `let` ，使变量拥有数据的所有权
  * 实际上的操作为：定义一个变量，且“绑定”一个内存的值

  ```rust
  let s1 = String::from("hello");
  let x = 5;
  ```

### 1.4 `let x = y` 变量间赋值问题的不同处理

场景：用一个变量给另一个变量“赋值”时

* 只在栈上的数据：**拷贝**

  * Rust 定义了 Copy 特型 (trait)，表示一种类型可以拷贝，而不是用默认的移动语义

  * 行为

    * 再在栈上创建另一份与x相同的值，绑定给y

  * 原因

    * 这种类型轻量级，且位于栈上，直接使用<u>按位进行</u>的拷贝行为，性能很高

  * 大多数基本类型是 Copy 类型（i32、f64、char、bool 等等）。

    ![image-20221105023227341](C:\Users\11731\AppData\Roaming\Typora\typora-user-images\image-20221105023227341.png)

  * 包含引用的类型不是 Copy 类型（例如，Vec、String）

    ```rust
    # fn main() {
    let x = 5;
    let y = x;	//2个5都被放入了栈中,x和y都是有效的
    # }
    ```

* 默认行为：**移动**所有权

  * 移动(move)操作：

    * 当 `let y = x` 后，Rust 把原来 `x` 对应的内存值的**所有权，从 `x` 转移给了 `y`**。且认为 `x` 不再有效（不能再访问 `x`）

  * 对于在<u>堆上存储的复杂类型</u>，有点像c++中的“浅拷贝”。但使x无效了，成功避免了“二次释放”问题

    * 移动所有权是编译时的语义，不涉及程序运行时的数据移动。因而高效
    * 移动所有权 + 所有权三大规则，使 Rust 能够在编译时发现内存分配的潜在隐患，从而抛出编译错误，高可靠

    ```rust
    let s1 = String::from("hello");
    let s2 = s1;
    
    println!("{}, world!", s1); //error
    ```

* 拓展：克隆(深拷贝)

  * 对于复杂类型，Rust 永远也<u>不会自动</u>创建数据的 “深拷贝”。	

    * 因为涉及到运行时堆上的内存分配，很慢
    * 保证了任何**自动**的复制都不是深拷贝，可以被认为对运行时性能影响较小

  * 非要复制堆上的数据，可以使用一个叫做 `clone` 的方法

    ```rust
    let s1 = String::from("hello");
    let s2 = s1.clone();
    
    println!("s1 = {}, s2 = {}", s1, s2);
    ```

### 1.5 函数传值与返回

* 在函数的参数传递过程中，也会发生 移动 或 拷贝（隐式 `let` 语句）
* 但如果每次传递参数都要移交所有权，代码会变得十分繁琐
  * 进来时，交出所有权给形参；出去后，还要交还所有权给实参
* 采用 borrow 解决
  * 通过对变量取引用，来“借用”变量中的数据的所有权，此时所有权本身并没有发生变化
  * 当引用超过作用域，借用也随之结束
  * 原来的变量一直拥有对数据的所有权

## 2.引用与借用

* 引用类型 `&T`

  * 像一个指针，因为它的<u>值是一个地址</u>，可以由此<u>访问其指向的变量数据</u>。
  * 与指针不同的是，引用确保指向<u>某个特定类型的有效值</u>

* 通过 `&` 算符取地址，对引用类型赋值

  ```rust
  fn main() {
      let x = 5;
      let y = &x;	// y类型为 &i32
  }
  ```

* 引用与所有权

  * 我们将创建一个引用的行为称为 **借用**

    * 因为引用语法，让我们做到可以使用一个值的同时，但并不拥有它的所有权。
    * 因为并不拥有这个值，所以当引用停止使用时，它所指向的值也不会被丢弃

  * 当一个<u>变量有引用</u>存在时，<u>不能移交</u>它所绑定的数据的所有权

  * 在函数的参数传递中，采用引用类型，避免所有权的来回传递

    ```rust
    fn main() {
        let s1 = String::from("hello");
    
        let len = calculate_length(&s1);
    
        println!("The length of '{}' is {}.", s1, len);
    }
    
    fn calculate_length(s: &String) -> usize {
        s.len()
    }// 这里，s 离开了作用域。但因为它并不拥有引用值的所有权，
      // 所以什么也不会发生
    ```

    ![image-20221105024450100](C:\Users\11731\AppData\Roaming\Typora\typora-user-images\image-20221105024450100.png)

  * 可变与不可变引用
    * 不可变引用（默认），不允许修改引用的值
    * 可变引用，允许修改一个引用的值
  * **引用的规则**
    * 同一作用域，特定数据最多只能有<u>一个可变引用</u>
    * 同一作用域，特定数据的<u>可变引用与不可变引用不能同时存在</u>
    * 不能在某个对象不存在后，继续保留对它的引用（禁止悬垂引用）
    * [作用]：
      * 使 Rust 在<u>编译期</u>就<u>避免数据竞争</u>。以下行为会造成数据竞争
        * 两个或更多的指针同时访问同一数据
        * 至少有一个指针被用来写入数据
        * 没有同步数据访问的机制
      * 数据竞争会导致未定义行为，这种行为很可能超出我们的预期，难以在运行时追踪，并且难以诊断和修复
      * 而 Rust 避免了这种情况的发生，因为它甚至不会编译存在数据竞争的代码！

  * 引用的作用域

    * 早期的时候，引用的作用域跟变量作用域是一致的，某个花括号位置结束

    * 现在，采用 非词法生命周期 (NLL）

      * 2018 版新特性 
      * 对象或引用的生命周期取决于<u>控制流图</u>，而不是词法作用域

    * 引用的作用域变为：从创建开始，一直持续到它<u>最后一次使用</u>的地方（引用的生命周期提前结束）

      ```rust
      fn main() {
         let mut s = String::from("hello");
      
          let r1 = &s;
          let r2 = &s;
          println!("{} and {}", r1, r2);
          // 新编译器中，r1,r2作用域在这里结束
      	
          let r3 = &mut s;
          println!("{}", r3);
      } // 老编译器中，r1、r2、r3作用域在这里结束
        // 新编译器中，r3作用域在这里结束
      ```

      ```rust
      fn main() {
      let v = vec![1, 2, 3];
      let v_ref = &v;
      let v_new = v;	//新版本不会报错
      }
      ```

## 3. Slice 类型

* 切片是一种<u>特殊形态的引用</u>，表示引用序列中的一个片段
  * 所以没有引用对象的所有权
  
* 构造语法
  * `&x[s..t]` 
    * x为序列名
    * 右半开区间其中 s 和 t 还可以根据情况省略
  * 可变性以及引用的约束条件, 对切片同样适用
  
* 字符串String的slice: `&str`

  ```rust
  # fn main() {
  let s = String::from("hello world");
  let hello = &s[0..5];
  let world = &s[6..11];
  # }
  ```

  ![image-20221105032154005](C:\Users\11731\AppData\Roaming\Typora\typora-user-images\image-20221105032154005.png)

  * 字符串切片：`&str`
    * 另一种写法：`&[u8]`
    * 字符串字面值类型就是 `&str`
      * 它是一个指向二进制程序特定位置的 slice。
      * 这也就是为什么字符串字面值是不可变的；&str 是一个不可变引用

# 5.结构化数据

* 复合类型：

  * 顾名思义，复合类型是由其它类型<u>组合</u>而成的

  * 基本类型的局限性：**无法从更高的抽象层次去简化代码**，复合类型可以解决这个问题
  * 结构体就是复合类型的一种

## 1.字符串 `String`

### 1）基本概念

* 逻辑概念：由字符组成的连续集合

* Rust 在<u>语言级别</u>，只有一种字符串类型： `str`

  * 通常是以引用类型出现：`&str`，即字符串切片

* 在标准库里，还有多种不同用途的字符串类型，其中使用最广的即是 `String` 类型

  * `str` 类型是硬编码进可执行文件，也无法被修改
  * `String` 则是一个可增长、可改变且具有所有权的 UTF-8 编码字符串
    * 对 `String` 取引用，还是 `&str`

  * 当 Rust 用户提到字符串时，往往指的就是 `String`类型和 `&str` 字符串切片类型，这两个类型都是 UTF-8 编码
    * UTF-8编码
      * 字符串中，每个字符都是 **UTF-8** 编码，<u>长度不固定</u>，为 1~4B
      * 跟 `char` 不同，char是 Unicode 类型，占据 4B
      * 有助于大幅降低字符串所占用的内存空间

* 除了 `String` 类型的字符串，Rust 的标准库还提供了其他类型的字符串，例如 `OsString`， `OsStr`， `CsString` 和` CsStr` 等

### 2）字符串索引访问字符

* Rust不允许字符串索引 

  ```rust
  let s1 = String::from("hello");
  let h = s1[0];	//error
  ```

* 原因

  * UTF-8变长，取单个字节通常无意义
  * 因为索引操作，我们总是期望它的性能表现是 O(1)，然而对于 `String` 类型来说，无法保证这一点，因为 Rust 可能需要从 0 开始去遍历字符串来定位合法的字符

### 3）字符串切片 `&str`

* 字符串切片是非常危险的操作，因为切片的索引是通过字节来进行

* 需要程序员保证，索引的字节刚好落在<u>字符的边界上</u>，否则会造成程序崩溃

* 如中文，UTF-8中为3字节编码：

  ```rust
  let hello = "中国人";
  let s = &hello[0..2];	//会直接造成崩溃
  ```

### 4）操作字符串

* 对于可变字符串 `String` ,下面介绍 Rust 字符串的修改，添加，删除等常用方法

* 追加 Push

  * 使用 `push()` 方法, 在字符串<u>尾部</u>追加<u>字符</u> `char`

  * 使用 `push_str()` 方法，在字符串<u>尾部</u>追加<u>字符串字面量</u>

  * 说明

    * 都是在<u>原有的字符串</u>上追加，并不会返回新的字符串
    * 由于要修改原来的字符串，字符串必须是<u>可变的</u>，即字符串变量必须由 `mut` 关键字修饰

    ```rust
    fn main() {
        let mut s = String::from("Hello ");
        s.push('r');
        println!("追加字符 push() -> {}", s);
    
        s.push_str("ust!");
        println!("追加字符串 push_str() -> {}", s);
    }
    ```

* 插入 Insert

  * 使用 `insert()` 方法, 插入单个字符 `char`

  * `insert_str()` 方法, 插入字符串字面量

  * 说明

    * 需要传入两个参数
      * 第一个参数是字符（串）插入位置的索引 (把后面的往后挤)
        * 索引从 0 开始计数，如果越界则会发生错误
      * 第二个参数是要插入的字符（串），
    * 由于字符串插入操作要修改原来的字符串，则该字符串必须是<u>可变</u>的，即字符串变量必须由 `mut` 关键字修饰

    ```rust
    fn main() {
        let mut s = String::from("Hello rust!");
        s.insert(5, ',');
        println!("插入字符 insert() -> {}", s);
        s.insert_str(6, " I like");
        println!("插入字符串 insert_str() -> {}", s);
    }
    ```

* 替换 Replace

  * 把字符串中的某个字符串替换成其它的字符串

  * `replace()` 方法：

    * 可适用于 `String` 和 `&str` 类型
    * 接收两个参数
      * 第一个参数是要被替换的字符串
      * 第二个参数是新的字符串
    * 说明
      * 该方法会替换<u>所有匹配到</u>的字符串。
      * 该方法是返回一个<u>新的字符串</u>，而不是操作原来的字符串

    ```rust
    fn main() {
        let string_replace = String::from("I like rust. Learning rust is my favorite!");
        let new_string_replace = string_replace.replace("rust", "RUST");
        dbg!(new_string_replace);
    }
    ```

  * `replacen()` 方法

    * 可适用于 `String` 和 `&str` 类型
    * 接收三个参数
      * 前两个参数与 `replace()` 方法一样
      * 第三个参数是替换的个数
    * 说明：
      * 该方法是返回一个<u>新的字符串</u>，而不是操作原来的字符串

    ```rust
    fn main() {
        let string_replace = "I like rust. Learning rust is my favorite!";
        let new_string_replacen = string_replace.replacen("rust", "RUST", 1);
        dbg!(new_string_replacen);
    }
    ```

  * `replace_range` 方法

    * 仅适用于 `String` 类型

    * 接收两个参数

      * 第一个参数是要替换字符串的范围（Range）
      * 第二个参数是新的字符串

    * 说明

      * 该方法是直接操作<u>原来的字符串</u>，不会返回新的字符串。
      * 该方法需要使用 `mut` 关键字修饰

      ```rust
      fn main() {
          let mut string_replace_range = String::from("I like rust!");
          string_replace_range.replace_range(7..8, "R");
          dbg!(string_replace_range);
      }
      ```

* 删除 Delete

  * 都仅适用于 `String` 类型

  * `pop()` 

    * 删除并返回字符串的<u>最后一个字符</u>

    * 该方法是直接操作原来的字符串

      * 需要 `mut` 类型

    * 存在返回值，其返回值是一个 `Option` 类型，如果字符串为空，则返回 `None`

      ```rust
      fn main() {
          let mut string_pop = String::from("rust pop 中文!");
          let p1 = string_pop.pop();
          let p2 = string_pop.pop();
          dbg!(p1);
          dbg!(p2);
          dbg!(string_pop);
      }
      ```

  * `remove()` 

    * 删除并返回字符串中<u>指定位置的字符</u>

    * 该方法是直接操作原来的字符串

      * 需要 `mut` 类型

    * 只接收一个参数，表示该<u>字符起始索引</u>位置

    * 存在返回值，其返回值是删除位置的字符串

    * 是按照<u>字节</u>来处理字符串的

      * 如果参数所给的位置不是合法的字符边界，则会发生错误

      ```rust
      fn main() {
          let mut string_remove = String::from("测试remove方法");
          println!(
              "string_remove 占 {} 个字节",
              std::mem::size_of_val(string_remove.as_str())
          );
          // 删除第一个汉字
          string_remove.remove(0);
          // 下面代码会发生错误
          // string_remove.remove(1);
          // 直接删除第二个汉字
          // string_remove.remove(3);
          dbg!(string_remove);
      }
      ```

  * `truncate()` 

    * 删除字符串中从<u>指定位置开始到结尾</u>的全部字符

    * 该方法是直接操作原来的字符串

      * 需要 `mut` 类型

    * 只接收一个参数，表示该<u>字符起始索引</u>位置

    * 无返回值

    * 是按照<u>字节</u>来处理字符串的

      * 如果参数所给的位置不是合法的字符边界，则会发生错误

      ```rust
      fn main() {
          let mut string_truncate = String::from("测试truncate");
          string_truncate.truncate(3);
          dbg!(string_truncate);
      }
      ```

  * `clear()`

    * 清空字符串。调用后，删除字符串中的所有字符

      * 相当于 `truncate()` 方法参数为 0 的时候

    * 该方法是直接操作原来的字符串

      * 需要 `mut` 类型

      ```rust
      fn main() {
          let mut string_clear = String::from("string clear");
          string_clear.clear();
          dbg!(string_clear);
      }
      ```

* 连接 Concatenate

  * 使用 `+` 或者 `+=` 

    * 要求右边的参数必须为字符串的切片引用（Slice）类型

      * 不能直接传递 `String` 类型

    * 都是返回一个新的字符串。

      ```rust
      fn main() {
          let string_append = String::from("hello ");
          let string_rust = String::from("rust");
          // &string_rust会自动解引用为&str
          let result = string_append + &string_rust;
          let mut result = result + "!";
          result += "!!!";
      
          println!("连接字符串 + -> {}", result);
      }
      ```

    * 当调用 + 的操作符时，相当于调用了 std::string 标准库中的 `add()` 方法

      * S 调用 `add()` 方法后，会丧失所有权

      ```rust
      fn add(self, s: &str) -> String
      ```

  * 使用 `format!` 

    * 适用于 `String` 和 `&str`

      ```rust
      fn main() {
          let s1 = "hello";
          let s2 = String::from("rust");
          let s = format!("{} {}!", s1, s2);
          println!("{}", s);
      }
      ```

* 字符串转义

  * 可以通过转义的方式 `\` 输出 ASCII 和 Unicode 字符

* 操作 UTF-8 字符串

  * `chars()` 方法

    * 以 Unicode 字符的方式遍历字符串

      ```rust
      for c in "中国人".chars() {
          println!("{}", c);
      }
      ```

  * `bytes()` 方法

    * 返回字符串的<u>底层字节数组</u>表现形式

      ```rust
      for b in "中国人".bytes() {
          println!("{}", b);
      }
      /*输出
      228
      184
      173
      229
      155
      189
      228
      186
      186 */
      ```

  * 获取子串

    * 想要准确的从 UTF-8 字符串中获取子串是较为复杂的事情
    * 使用标准库你是做不到的。 你需要在 `crates.io` 上搜索 `utf8` 来寻找想要的功能

### 5）深入字符串

* `str` 
  * 字符串字面值，在编译时就知道其内容，最终字面值文本被直接硬编码进可执行文件中
  * 这使得字符串字面值快速且高效，这主要得益于字符串字面值的不可变性
* `String` 
  * 为了支持一个可变、可增长的文本片段
  * 需要在<u>堆</u>上分配一块在编译时未知大小的内存来存放内容，这些都是在程序运行时完成的
    * 首先向操作系统请求内存来存放 `String` 对象
      * 由 `String::from` 完成，它创建了一个全新的 `String`
    * 在使用完成后，将内存释放，归还给操作系统
      * 在所属变量离开作用域时，自动调用 `drop` 函数，释放内存
      * 比如，一般在 `}` 处自动调用 `drop`。

## 2.元组
